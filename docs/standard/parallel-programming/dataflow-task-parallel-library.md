---
title: Fluxo de dados (Task Parallel Library)
description: Saiba como usar componentes de fluxo de aplicativos na TPL (biblioteca paralela de tarefas) para melhorar a robustez de aplicativos habilitados para simultaneidade.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
ms.openlocfilehash: 2c7bbc9bf935159ab66bd2a61a60b9484e67018a
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 06/10/2020
ms.locfileid: "84662544"
---
# <a name="dataflow-task-parallel-library"></a>Fluxo de dados (Task Parallel Library)
 A TPL (biblioteca de paralelismo de tarefas) fornece componentes de fluxo de dados para ajudar a aumentar a robustez de aplicativos habilitados para simultaneidade. Esses componentes de fluxo de dados são coletivamente chamados de *biblioteca de fluxos de dados TPL*. Esse modelo de fluxo de dados promove programação baseada em ator que fornece transmissão de mensagem no processo para fluxo de dados de alta granularidade e tarefas de pipelining. Os componentes de fluxo de dados baseiam-se nos tipos e na infraestrutura de agendamento da TPL e integram-se ao suporte às linguagens C#, Visual Basic e F# para programação assíncrona. Esses componentes do fluxo de dados são úteis quando você tem várias operações que devem se comunicar umas com as outras de modo assíncrono ou quando você deseja processar dados à medida que são disponibilizados. Por exemplo, considere um aplicativo que processa dados de imagem de uma webcam. Usando o modelo de fluxo de dados, o aplicativo pode processar quadros de imagem assim que eles se tornarem disponíveis. Se o aplicativo aprimora os quadros de imagem, por exemplo, executando a redução de olhos vermelhos ou correção de luz, você pode criar um *pipeline* dos componentes de fluxo de dados. Cada estágio do pipeline pode usar mais funcionalidade de paralelismo de alta granularidade, assim como a funcionalidade fornecida pela TPL, para transformar a imagem.  
  
 Este documento fornece uma visão geral da biblioteca de fluxos de dados TPL. Ele descreve o modelo de programação, os tipos de blocos de fluxo de dados predefinidos e como configurar os blocos de fluxo de dados para atender os requisitos específicos de seus aplicativos.  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]

## <a name="programming-model"></a>Modelo de Programação
 A biblioteca de fluxos de dados TPL fornece uma base para a transmissão de mensagens e a paralelização de aplicativos com uso intensivo de CPU e de E/S que têm alta taxa de transferência e baixa latência. Ela também fornece controle explícito sobre como os dados são armazenados em buffer e se movem pelo sistema. Para entender melhor o modelo de programação de fluxo de dados, considere um aplicativo que carrega imagens do disco de forma assíncrona e cria uma composição dessas imagens. Modelos de programação tradicionais normalmente exigem que você use retornos de chamada e objetos de sincronização, tais como bloqueios, para coordenar tarefas e acesso a dados compartilhados. Usando o modelo de programação de fluxo de dados, você pode criar objetos de fluxo de dados que processam imagens conforme elas são lidas do disco. No modelo de fluxo de dados, você declara como os dados serão manipulados quando se tornarem disponíveis e também quaisquer eventuais dependências entre os dados. Já que o runtime gerencia as dependências entre os dados, muitas vezes você pode evitar a necessidade de sincronizar o acesso aos dados compartilhados. Além disso, já que o runtime agenda o trabalho com base na chegada assíncrona de dados, o fluxo de dados pode aumentar a capacidade de resposta e a taxa de transferência ao gerenciar com eficiência os threads subjacentes. Para obter um exemplo que usa o modelo de programação de fluxo de dados para implementar o processamento de imagens em um aplicativo Windows Forms, consulte [Passo a passo: usando um fluxo de dados em um Aplicativo do Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Origens e Destinos  
 A biblioteca de fluxos de dados TPL consiste em *blocos de fluxo de dados*, que são estruturas de dados que armazenam dados em buffer e os processam. A TPL define três tipos de blocos de fluxo de dados: *blocos de origem*, *blocos de destino* e *blocos propagadores*. Um bloco de origem atua como uma fonte de dados e possibilita a leitura de dados presentes nele. Um bloco de destino atua como um receptor de dados e possibilita que nele sejam gravados dados. Um bloco propagador atua como um bloco de origem e um bloco de destino e possibilita tanto leitura quanto gravação. A TPL define a interface <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> para representar origens, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> para representar destinos e <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> para representar propagadores. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> herda de <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> e de <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 A Biblioteca de fluxos de dados TPL fornece vários tipos de bloco de fluxo de dados predefinidos que implementam as interfaces <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> e <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>. Esses tipos de bloco de fluxo de dados são descritos neste documento na seção [Tipos de bloco de fluxo de dados predefinidos](#predefined-dataflow-block-types).  
  
### <a name="connecting-blocks"></a>Conectar blocos  
 Você pode conectar blocos de fluxo de dados para formar *pipelines*, que são sequências lineares de blocos de fluxo de dados, ou então *redes*, que são gráficos de blocos de fluxo de dados. Um pipeline é uma forma de rede. Em uma rede ou pipeline, origens propagam dados assincronamente para destinos assim que os dados ficam disponíveis. O método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> vincula um bloco de fluxo de dados de origem a um bloco de destino. Uma origem pode ser vinculada a zero ou mais destinos, enquanto os destinos podem ser vinculados de zero ou mais origens. Você pode adicionar ou remover blocos de fluxo de dados para ou de um pipeline ou rede simultaneamente. Os tipos de bloco de fluxo de dados predefinidos tratam de todos os aspectos de acesso thread-safe de vincular e desvincular.  
  
 Para obter um exemplo que conecta os blocos de fluxo de dados para formar um pipeline básico, consulte [Passo a passo: criando um pipeline de fluxo de dados](walkthrough-creating-a-dataflow-pipeline.md). Para obter um exemplo que conecta os blocos de fluxo de dados para formar uma rede mais complexa, consulte [Passo a passo: usando o fluxo de dados em um Aplicativo do Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md). Para obter um exemplo que desvincula um destino de uma origem depois que a origem oferece uma mensagem ao destino, consulte [Como desvincular blocos de fluxo de dados](how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtragem  
 Ao chamar o método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> para vincular uma origem a um destino, você pode fornecer um representante que determina se o bloco de destino aceita ou rejeita uma mensagem com base no valor dela. Esse mecanismo de filtragem é uma maneira útil para garantir que um bloco de fluxo de dados receba apenas determinados valores. Para a maioria dos tipos de bloco de fluxo de dados predefinidos, se um bloco de origem estiver conectado a vários blocos de destino, quando um bloco de destino rejeitar uma mensagem, a origem oferecerá essa mensagem para o próximo destino. A ordem em que uma origem oferece mensagens para destinos é definida pela origem e pode variar de acordo com o tipo da origem. A maioria dos tipos de blocos de origem para de oferecer uma mensagem depois que um destino aceita essa mensagem. Uma exceção a essa regra é a classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, que oferece cada mensagem para todos os destinos, mesmo que alguns destinos rejeitem a mensagem. Para obter um exemplo que usa a filtragem para processar apenas mensagens específicas, consulte [Passo a passo: usando o fluxo de dados em um Aplicativo do Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
> Já que cada tipo de bloco de fluxo de dados de origem predefinido garante que as mensagens sejam propagadas na ordem em que são recebidas, toda mensagem deve ser lida do bloco de origem antes que o bloco de origem possa processar a próxima mensagem. Portanto, quando você usa a filtragem para conectar vários destinos a uma origem, certifique-se de que pelo menos um bloco de destino receba cada mensagem. Caso contrário, seu aplicativo poderá sofrer deadlock.  
  
### <a name="message-passing"></a>Transmissão de mensagens  
 O modelo de programação de fluxo de dados está relacionado ao conceito de *transmissão de mensagens*, em que componentes independentes de um programa se comunicam uns com os outros pelo envio de mensagens. Uma maneira de propagar mensagens entre componentes de aplicativos é chamar os métodos <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> e <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> para enviar mensagens à postagem de blocos de fluxo de dados de destino (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> age de forma síncrona; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> age de forma assíncrona) e os métodos <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A> e <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> para receber mensagens de blocos da origem. Você pode combinar esses métodos com redes ou pipelines de fluxo de dados por meio do envio de dados de entrada para o nó de cabeçalho (um bloco de destino) e receber dados de saída do nó terminal do pipeline ou nós terminais da rede (um ou mais blocos de origem). Você também pode usar o método <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> para ler a partir da primeira origem fornecida que tem dados disponíveis e executar ações nesses dados.  
  
 Os blocos de código-fonte oferecem dados ao blocos de destino chamando o método <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType>. O bloco de destino responde a uma mensagem oferecida em uma destas três maneiras: ele pode aceitar a mensagem, recusá-la ou adiá-la. Quando o destino aceita a mensagem, o método <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> retornará <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>. Quando o destino rejeita a mensagem, o método <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> retornará <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>. Quando o destino exige não receber mais as mensagens da origem, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> retornará <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>. Os tipos de bloco de origem predefinidos não oferecem mensagens para destinos vinculados após o recebimento desse valor retornado e eles se desvinculam automaticamente desses destinos.  
  
 Quando um bloco de destino adia a mensagem para uso posterior, o método <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> retornará <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>. Um bloco de destino que adia uma mensagem pode mais tarde chamar o método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> para tentar reservar a mensagem oferecida. Neste ponto, é possível que a mensagem ainda esteja disponível e possa ser usada pelo bloco de destino ou então que a mensagem tenha sido tomada por outro destino. Quando, posteriormente, o bloco de destino exige a mensagem ou já não precisa dela, ele chama o método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A>, respectivamente. Reserva de mensagem normalmente é usada pelos tipos de bloco de fluxo de dados que operam em modo não greedy. O modo não greedy é explicado mais adiante neste documento. Em vez de reservar uma mensagem adiada, um bloco de destino também pode usar o método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> para tentar consumir diretamente a mensagem adiada.  
  
### <a name="dataflow-block-completion"></a>Conclusão do bloco de fluxo de dados  
 Blocos de fluxo de dados também dão suporte ao conceito de *conclusão*. Um bloco de fluxo de dados que está no estado concluído não executa nenhum trabalho adicional. Cada bloco de fluxo de dados tem um objeto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> associado, conhecido como uma *tarefa de conclusão* que representa o status de conclusão do bloco. Já que você pode esperar a conclusão de um objeto <xref:System.Threading.Tasks.Task> por meio do uso de tarefas de conclusão, espere pela conclusão de um ou mais nós terminais de uma rede de fluxo de dados. A interface <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> define o método <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> que informa o bloco de fluxo de dados sobre uma solicitação para que ela seja concluída e a propriedade <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> que retorna a tarefa de conclusão para o bloco de fluxo de dados. <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> e <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> herdam a interface <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>.  
  
 Há duas maneiras de determinar se um bloco de fluxo de dados foi concluído sem erros, encontrou um ou mais erros ou foi cancelado. A primeira maneira é chamar o método <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> na tarefa de conclusão em um bloco `try`-`catch` (`Try`-`Catch` no Visual Basic). O exemplo a seguir cria um objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> que gera <xref:System.ArgumentOutOfRangeException> se o valor de entrada for menor que zero. <xref:System.AggregateException> é gerado quando este exemplo chama <xref:System.Threading.Tasks.Task.Wait%2A> na tarefa de conclusão. O <xref:System.ArgumentOutOfRangeException> pode ser acessado pela propriedade <xref:System.AggregateException.InnerExceptions%2A> do objeto <xref:System.AggregateException>.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 Este exemplo demonstra o caso em que uma exceção fica sem tratamento no delegado de um bloco de fluxo de dados de execução. É recomendável que você trate exceções nos corpos de tais blocos. No entanto, se não for possível fazer isso, o bloco se comportará como se tivesse sido cancelado e não processará mensagens de entrada.  
  
 Quando um bloco de fluxo de dados é explicitamente cancelado, o objeto <xref:System.AggregateException> contém <xref:System.OperationCanceledException> na propriedade <xref:System.AggregateException.InnerExceptions%2A>. Para obter mais informações sobre o cancelamento de fluxo de dados, consulte a seção [Habilitando o cancelamento](#enabling-cancellation).  
  
 A segunda maneira de determinar o status de conclusão de um bloco de fluxo de dados é usar uma continuação da tarefa de conclusão ou então usar os recursos de linguagem assíncrona do C# e Visual Basic para aguardar de modo assíncrono a tarefa de conclusão. O representante que você fornece ao método <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> usa um objeto <xref:System.Threading.Tasks.Task> que representa a tarefa antecedente. No caso da propriedade <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>, o próprio representante para a continuação recebe a tarefa de conclusão. O exemplo a seguir é semelhante ao anterior, exceto pelo fato de que ele também usa o método <xref:System.Threading.Tasks.Task.ContinueWith%2A> para criar uma tarefa de conclusão que imprime o status da operação de fluxo de dados geral.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Você também pode usar propriedades como <xref:System.Threading.Tasks.Task.IsCanceled%2A> no corpo da tarefa de continuação para determinar informações adicionais sobre o status de conclusão de um bloco de fluxo de dados. Para obter mais informações sobre tarefas de continuação e como elas se relacionam com cancelamento e tratamento de erro, consulte [Encadeamento de tarefas pelo uso de tarefas de continuação](chaining-tasks-by-using-continuation-tasks.md), [Cancelamento de tarefas](task-cancellation.md) e [Tratamento de exceções](exception-handling-task-parallel-library.md).  

## <a name="predefined-dataflow-block-types"></a>Tipos de bloco de fluxo de dados predefinidos  
 A biblioteca de fluxos de dados TPL fornece vários tipos de bloco de fluxo de dados predefinidos. Esses tipos são divididos em três categorias: *blocos de buffer*, *blocos de execução* e *blocos de agrupamento*. As seções a seguir descrevem os tipos de bloco que compõem essas categorias.  
  
### <a name="buffering-blocks"></a>Blocos de buffer  
 Blocos de buffer armazenam dados para uso pelos consumidores de dados. A Biblioteca de fluxos de dados TPL fornece três tipos de blocos de buffer: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType> e <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 A classe <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> representa uma estrutura de sistema de mensagens assíncrona para fins gerais. Essa classe armazena uma fila PEPS (primeiro a entrar, primeiro a sair) de mensagens que podem ser gravadas por várias origens ou lidas por vários destinos. Quando um destino recebe uma mensagem de um objeto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, essa mensagem é removida da fila de mensagens. Portanto, embora um objeto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> possa ter vários destinos, cada mensagem será recebida por apenas um destino. A classe <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> é útil quando você deseja passar várias mensagens para outro componente e esse componente deve receber cada uma das mensagens.  
  
 O exemplo básico a seguir posta diversos valores <xref:System.Int32> em um objeto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> e, em seguida, lê esses valores de volta a partir desse objeto.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Para obter um exemplo completo que demonstra como gravar mensagens e ler mensagens de um objeto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, confira [Como gravar mensagens em um bloco de fluxo de dados e ler mensagens de um bloco de fluxo de dados](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 A classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> é útil quando você precisa passar várias mensagens para outro componente mas esse componente precisa apenas do valor mais recente. Essa classe também é útil quando você deseja difundir uma mensagem para vários componentes.  
  
 O exemplo básico a seguir posta diversos valores <xref:System.Double> em um objeto <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> e, em seguida, lê esses valores de volta a partir desse objeto por diversas vezes. Como valores não são removidos dos objetos <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> depois que eles são lidos, o mesmo valor está disponível todas as vezes.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Para obter um exemplo completo que demonstra como usar <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> para difundir uma mensagem a vários blocos de destino, confira [Como especificar um agendador de tarefas em um bloco de fluxo de dados](how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 A classe <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> é semelhante à classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, exceto no ponto em que um objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> pode ser gravado apenas uma vez. Você pode pensar em <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> como sendo semelhante à palavra-chave de C# [readonly](../../csharp/language-reference/keywords/readonly.md) ([ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md) no Visual Basic), exceto pelo fato de que um objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> torna-se imutável depois de receber um valor em vez de uma construção. Como na classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, quando um destino recebe uma mensagem de um objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>, essa mensagem não é removida do objeto. Portanto, vários destinos recebem uma cópia da mensagem. A classe <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> é útil quando você deseja propagar apenas a primeira de várias mensagens.  
  
 O exemplo básico a seguir posta diversos valores <xref:System.String> em um objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> e, em seguida, lê esse valor de volta a partir desse objeto. Como um objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> pode ser gravado apenas uma vez, após um objeto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> receber uma mensagem, ele descartará mensagens subsequentes.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Para obter um exemplo completo que demonstra como usar <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> para receber o valor da primeira operação que termina, confira [Como desvincular blocos de fluxo de dados](how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Blocos de execução  
 Blocos de execução chamam um delegado fornecido pelo usuário para cada parte dos dados recebidos. A Biblioteca de Fluxos de Dados TPL fornece três tipos de blocos de execução: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 A classe <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> é um bloco de destino que chama um representante ao receber dados. Pense em um objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> como um representante que é executado de modo assíncrono quando os dados se tornam disponíveis. O representante que você fornece a um objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> pode ser do tipo <xref:System.Action%601> ou tipo `System.Func<TInput, Task>`. Quando você usa um objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> com <xref:System.Action%601>, o processamento de cada elemento de entrada é considerado concluído quando o representante retorna. Quando você usa um objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> com `System.Func<TInput, Task>`, o processamento de cada elemento de entrada é considerado concluído somente quando o objeto retornado <xref:System.Threading.Tasks.Task> for concluído. Usando esses dois mecanismos, você pode usar <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> no processamento síncrono e assíncrono de cada elemento de entrada.  
  
 O exemplo simples a seguir envia vários valores <xref:System.Int32> para um objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>. O objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> imprime esses valores para o console. Este exemplo, em seguida, define o bloco para o estado concluído e aguarda que todas as tarefas de fluxo de dados sejam concluídas.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Para concluir exemplos que demonstram como usar representantes com a classe <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, confira [Como executar ações quando um bloco de fluxo de dados recebe dados](how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 A classe <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> é semelhante à classe <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, exceto que ela atua tanto como origem quanto destino. O representante que você passa para um objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> retorna um valor do tipo `TOutput`. O representante que você fornece a um objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> pode ser do tipo `System.Func<TInput, TOutput>` ou do tipo `System.Func<TInput, Task<TOutput>>`. Quando você usa um objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> com `System.Func<TInput, TOutput>`, o processamento de cada elemento de entrada é considerado concluído quando o representante retorna. Quando você usa um objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> com `System.Func<TInput, Task<TOutput>>`, o processamento de cada elemento de entrada é considerado concluído somente quando o objeto retornado <xref:System.Threading.Tasks.Task%601> for concluído. Como acontece com o <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, ao usar esses dois mecanismos, você pode usar <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> no processamento síncrono e assíncrono de cada elemento de entrada.  
  
 O exemplo básico a seguir cria um objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> que computa a raiz quadrada de sua entrada. O objeto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> usa valores <xref:System.Int32> como entrada e produz valores <xref:System.Double> como saída.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Para obter exemplos completos que usam <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> em uma rede de blocos de fluxo de dados que executa o processamento de imagem em um Aplicativo do Windows Forms, confira [Explicação passo a passo: usar o fluxo de dados em um Aplicativo Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 A classe <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> é semelhante à classe <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, exceto no ponto em que <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produz zero ou mais valores de saída para cada valor de entrada, em vez de apenas um valor para cada valor de entrada de saída. O representante que você fornece a um objeto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> pode ser do tipo `System.Func<TInput, IEnumerable<TOutput>>` ou do tipo `System.Func<TInput, Task<IEnumerable<TOutput>>>`. Quando você usa um objeto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> com `System.Func<TInput, IEnumerable<TOutput>>`, o processamento de cada elemento de entrada é considerado concluído quando o representante retorna. Quando você usa um objeto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> com `System.Func<TInput, Task<IEnumerable<TOutput>>>`, o processamento de cada elemento de entrada é considerado concluído somente quando o objeto retornado `System.Threading.Tasks.Task<IEnumerable<TOutput>>` for concluído.  
  
 O exemplo básico a seguir cria um objeto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> que divide cadeias de caracteres em suas sequências de caracteres individuais. O objeto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> usa valores <xref:System.String> como entrada e produz valores <xref:System.Char> como saída.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Para obter exemplos completos que usam <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> para produzir várias saídas independentes para cada entrada em um pipeline de fluxo de dados, confira [Explicação passo a passo: criar um pipeline de fluxo de dados](walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Grau de paralelismo  
 Cada objeto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> armazena mensagens de entrada até que o bloco esteja pronto para processá-las. Por padrão, essas classes processam mensagens na ordem em que elas são recebidas, uma mensagem por vez. Você também pode especificar o grau de paralelismo para habilitar os objetos <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> para processar várias mensagens simultaneamente. Para obter mais informações sobre a execução simultânea, consulte a seção Especificando o grau de paralelismo, presente neste documento. Para obter um exemplo que define o grau de paralelismo para habilitar um bloco de fluxo de dados de execução a processar mais de uma mensagem por vez, consulte [Como especificar o grau de paralelismo em um bloco de fluxo de dados](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Resumo de tipos de delegados  
 A tabela a seguir resume os tipos de representantes que você pode fornecer aos objetos <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>. Esta tabela também especifica se o tipo de delegado opera de forma síncrona ou assíncrona.  
  
|Type|Tipo de delegado síncrono|Tipo de delegado assíncrono|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Você também pode usar expressões lambda ao trabalhar com tipos de blocos de execução. Para obter um exemplo que mostra como usar uma expressão lambda com um bloco de execução, consulte [Como executar ações quando um bloco de fluxo de dados recebe dados](how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Blocos de agrupamento  
 Blocos de agrupamento combinam dados de uma ou mais origens e sob várias restrições. A Biblioteca de fluxos de dados TPL fornece três tipos de blocos de junção: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 A classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> combina os conjuntos de dados de entrada, que são conhecidos como lotes, em matrizes de dados de saída. Especifique o tamanho de cada lote ao criar um objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>. Quando o objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> recebe a contagem especificada dos elementos de entrada, ele propaga, de modo assíncrono, uma matriz que contém esses elementos. Se um objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> estiver definido com o estado concluído, mas não contiver elementos suficientes para formar um lote, ele propagará uma matriz final com os elementos de entrada restantes.  
  
 A classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> opera em qualquer um dos modos *greedy* ou *não greedy*. No modo greedy, que é o padrão, um objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> aceita todas as mensagens que são oferecidas a ele e propaga uma matriz, depois de receber a contagem especificada de elementos. No modo não greedy, um objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> adia todas as mensagens de entrada até que origens suficientes tenham oferecido mensagens para que o bloco forme um lote. O modo greedy normalmente tem melhor desempenho do que o modo não greedy porque ele requer menos sobrecarga de processamento. No entanto, você pode usar o modo não greedy quando você deve coordenar o consumo de várias origens de maneira atômica. Especifique o modo não greedy definindo <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> como `False` no parâmetro `dataflowBlockOptions` no constructo <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A>.  
  
 O exemplo básico a seguir posta diversos valores <xref:System.Int32> em um objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> que contém dez elementos em um lote. Para garantir que todos os valores sejam propagados fora do <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, este exemplo chama o método <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>. O método <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> define o objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> com o estado concluído e, assim, o objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> propaga quaisquer elementos restantes como um lote final.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Para obter um exemplo completo que usa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> para aumentar a eficiência das operações de inserção do banco de dados, confira [Explicação passo a passo: usar BatchBlock e BatchedJoinBlock para melhorar a eficiência](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 As classes <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> coletam elementos de entrada e os propaga fora dos objetos <xref:System.Tuple%602?displayProperty=nameWithType> ou <xref:System.Tuple%603?displayProperty=nameWithType> que contêm esses elementos. As classes <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> não são herdadas de <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Em vez disso, eles fornecem propriedades, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, que implementam <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Da mesma forma que <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> operam em qualquer um dos modos greedy ou não greedy. No modo greedy, que é o padrão, um objeto <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> ou <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> aceita todas as mensagens que são oferecidas a ele e propaga uma tupla depois de cada um dos seus destinos receber pelo menos uma mensagem. No modo não greedy, um objeto <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> ou <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> adia todas as mensagens de entrada até que os dados que são necessários para criar uma tupla tenham sido oferecidos para todos os destinos. Neste ponto, o bloco se envolve em um protocolo 2PC para recuperar atomicamente todos os itens obrigatórios das origens. Este adiamento possibilita que outra entidade consuma os dados e, enquanto isso, permite que o sistema em geral avance.  
  
 O exemplo básico a seguir demonstra um caso em que um objeto <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> requer vários dados para calcular um valor. Este exemplo cria um objeto <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> que requer dois valores <xref:System.Int32> e um valor <xref:System.Char> para executar uma operação aritmética.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Para obter um exemplo completo que usa objetos <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> no modo não greedy para compartilhar um recurso cooperativamente, confira [Como usar JoinBlock para ler dados de várias origens](how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 As classes <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> coletam lotes de elementos de entrada e os propaga fora dos objetos `System.Tuple(IList(T1), IList(T2))` ou `System.Tuple(IList(T1), IList(T2), IList(T3))` que contêm esses elementos. Pense em <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> como uma combinação de <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>. Especifique o tamanho de cada lote ao criar um objeto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> também fornece propriedades, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, que implementam <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Quando a contagem especificada dos elementos de entrada é recebida do conjunto de todos os destinos, o objeto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> propaga, de modo assíncrono, um objeto `System.Tuple(IList(T1), IList(T2))` que contém esses elementos.  
  
 O exemplo básico a seguir cria um objeto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> que contém resultados, valores <xref:System.Int32> e erros que são objetos <xref:System.Exception>. Este exemplo executa várias operações e grava os resultados na propriedade <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> e os erros na propriedade <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> do objeto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. Já que não se sabe com antecedência a contagem de operações bem-sucedidas e com falha, os objetos <xref:System.Collections.Generic.IList%601> permitem que cada destino receba zero ou mais valores.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Para obter um exemplo completo que usa <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> para capturar os resultados e todas as exceções que ocorrem enquanto o programa lê de um banco de dados, confira [Explicação passo a passo: usar BatchBlock e BatchedJoinBlock para aumentar a eficiência](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  

## <a name="configuring-dataflow--block-behavior"></a>Configurar o comportamento de bloco de fluxo de dados  
 Você pode habilitar as opções adicionais, fornecendo um objeto <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> ao constructo de tipos de bloco de fluxo de dados. Essas opções controlam comportamentos como o do agendador que gerencia a tarefa subjacente e o grau de paralelismo. O <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> também tem tipos derivados que especificam comportamentos que são específicos de determinados tipos de bloco de fluxo de dados. A tabela a seguir resume que tipo de opções é associado a cada tipo de bloco de fluxo de dados.  
  
|Tipo de bloco de fluxo de dados|Tipo<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 As seções a seguir fornecem mais informações sobre os tipos importantes de opções de blocos de fluxo de dados que estão disponíveis por meio das classes <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType> e <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType>.  
  
### <a name="specifying-the-task-scheduler"></a>Especificando o Agendador de Tarefas  
 Cada bloco de fluxo de dados predefinidos usa o mecanismo de agendamento de tarefas TPL para executar atividades como a propagação de dados para um destino, o recebimento de dados de uma origem e a execução de delegados definidos pelo usuário quando os dados tornam-se disponíveis. <xref:System.Threading.Tasks.TaskScheduler> é uma classe abstrata que representa um agendador de tarefas que coloca as tarefas na fila, em threads. O agendador de tarefas padrão, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, usa a classe <xref:System.Threading.ThreadPool> para colocar o trabalho na fila e executá-lo. Você pode substituir o agendador de tarefas padrão definindo a propriedade <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> ao construir um objeto de bloco de fluxo de dados.  
  
 Quando o mesmo agendador de tarefas gerencia vários blocos de fluxo de dados, ele pode impor políticas entre eles. Por exemplo, se cada um dos vários blocos de fluxo de dados forem configurados para usar como destino o agendador exclusivo do mesmo objeto <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>, todo o trabalho que é executado entre esses blocos será serializado. De modo similar, se esses blocos são configurados para usar como destino o agendador simultâneo do mesmo objeto <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> e esse agendador é configurado para ter um nível de simultaneidade máximo, todo o trabalho desses blocos é limitado a esse número de operações simultâneas. Para obter um exemplo que usa a classe <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> para habilitar a realização de operações de leitura em paralelo mas mantém as operações de gravação ocorrendo de modo exclusivo com relação a todas as outras operações, confira [Como especificar um agendador de tarefas em um bloco de fluxo de dados](how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Para saber mais sobre os agendadores de tarefas na TPL, confira o tópico da classe <xref:System.Threading.Tasks.TaskScheduler>.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Especificando o grau de paralelismo  
 Por padrão, os três tipos de blocos de execução que a biblioteca de fluxo de dados TPL fornece, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, processam uma mensagem por vez. Esses tipos de bloco de fluxo de dados também processam mensagens na ordem em que elas são recebidas. Para habilitar esses blocos de fluxo de dados para processar mensagens simultaneamente, defina a propriedade <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> ao construir o objeto de bloco de fluxo de dados.  
  
 O valor padrão de <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> é 1 e isso garante que o bloco de fluxo de dados processa uma mensagem por vez. Definir essa propriedade como um valor maior que 1 permite que o bloco de fluxo de dados processe várias mensagens simultaneamente. Definir essa propriedade como <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> permite que o agendador de tarefas subjacente gerencie o grau máximo de simultaneidade.  
  
> [!IMPORTANT]
> Quando você especifica um grau máximo de paralelismo maior do que 1, várias mensagens são processadas simultaneamente e, portanto, as mensagens talvez não sejam processadas na ordem em que são recebidas. A ordem na qual as mensagens são a saída do bloco é, no entanto, a mesma na qual elas são recebidas.  
  
 Como a propriedade <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> representa o grau máximo de paralelismo, o bloco de fluxo de dados pode executar com um menor grau de paralelismo do que o especificado. O bloco de fluxo de dados pode usar um grau menor de paralelismo para atender aos seus requisitos funcionais ou porque há uma falta de recursos do sistema disponíveis. Um bloco de fluxo de dados nunca escolherá mais paralelismo do que você especificar.  
  
 O valor da propriedade <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> é exclusivo para cada objeto de bloco de fluxo de dados. Por exemplo, se cada um de quatro objetos de bloco de fluxo de dados especificar 1 para o grau máximo de paralelismo, todos esses objetos poderão potencialmente ser executados em paralelo.  
  
 Para obter um exemplo que define o grau máximo de paralelismo para permitir que operações demoradas ocorram em paralelo, consulte [Como especificar o grau de paralelismo em um bloco de fluxo de dados](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Especificando o número de mensagens por tarefa  
 Os tipos de bloco de fluxo de dados predefinidos usam tarefas para processar vários elementos de entrada. Isso ajuda a minimizar o número de objetos de tarefa que são necessários para processar dados, o que permite que aplicativos sejam executados com mais eficiência. No entanto, quando as tarefas de um conjunto de blocos de fluxo de dados estão processando dados, talvez seja necessário que as tarefas de outros blocos de fluxo de dados esperem o tempo de processamento colocando mensagens na fila. Para permitir melhor integridade entre tarefas de fluxo de dados, defina a propriedade <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A>. Quando <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> é definido como <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, que é o padrão, a tarefa usada por um bloco de fluxo de dados processa as mensagens que estiverem disponíveis. Quando <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> é definido com um valor diferente de <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, o bloco de fluxo de dados processa no máximo esse número de mensagens por objeto <xref:System.Threading.Tasks.Task>. Embora definir a propriedade <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> possa aumentar a honestidade entre tarefas, isso pode fazer com que o sistema crie mais tarefas do que o necessário, o que pode diminuir o desempenho.  
  
### <a name="enabling-cancellation"></a>Habilitando o cancelamento  
 A TPL fornece um mecanismo que permite que as tarefas coordenem o cancelamento de forma cooperativa. Para habilitar os blocos de fluxo de dados a participarem desse mecanismo de cancelamento, defina a propriedade <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A>. Quando esse objeto <xref:System.Threading.CancellationToken> é definido como estado cancelado, todos os blocos de fluxo de dados que monitoram esse token concluem a execução do seu item atual, mas não iniciam o processamento de itens subsequentes. Esses blocos de fluxo de dados também limpam quaisquer mensagens armazenadas em buffer, cancelam as conexões com quaisquer blocos de origem e de destino e fazem a transição para o estado cancelado. Ao fazer a transição para o estado cancelado, a propriedade <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> tem a propriedade <xref:System.Threading.Tasks.Task.Status%2A> definida como <xref:System.Threading.Tasks.TaskStatus.Canceled>, a menos que uma exceção ocorra durante o processamento. Nesse caso, <xref:System.Threading.Tasks.Task.Status%2A> está definido como <xref:System.Threading.Tasks.TaskStatus.Faulted>.  
  
 Para obter um exemplo que demonstra como usar cancelamento em um aplicativo Windows Forms, consulte [Como cancelar um bloco de fluxo de dados](how-to-cancel-a-dataflow-block.md). Para obter mais informações sobre cancelamento na TPL, consulte [Cancelamento da tarefa](task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Especificando comportamento greedy versus não greedy  
 Vários tipos de bloco de fluxo de dados de agrupamento podem operar em qualquer um dos modos *greedy* ou *não greedy*. Por padrão, os tipos de bloco de fluxo de dados predefinidos operam em modo greedy.  
  
 Para tipos de bloco de junção como <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, o modo greedy significa que o bloco aceita dados imediatamente, mesmo que os dados correspondentes com os quais se pretende realizar a junção não estejam disponíveis. O modo não greedy significa que o bloco adia todas as mensagens de entrada até que uma esteja disponível em cada um de seus destinos para concluir a junção. Se qualquer uma das mensagens adiadas não estiver mais disponível, o bloco de junção liberará todas as mensagens adiadas e reiniciará o processo. Para a classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, o comportamento greedy e não greedy é semelhante, exceto pelo fato de que no modo não greedy, um objeto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> adia todas as mensagens de entrada até que um número suficiente delas estejam disponíveis de origens distintas para completar um lote.  
  
 Para especificar o modo não greedy para um bloco de fluxo de dados, defina <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> como `False`. Para obter um exemplo que demonstra como usar o modo não greedy para habilitar vários blocos de junção compartilhar uma fonte de dados com mais eficiência, consulte [Como usar JoinBlock para ler dados de várias fontes](how-to-use-joinblock-to-read-data-from-multiple-sources.md).

## <a name="custom-dataflow-blocks"></a>Blocos de fluxo de dados personalizados  
 Embora a biblioteca de fluxo de dados TPL forneça muitos tipos de bloco predefinidos, você pode criar tipos de bloco adicionais que tenham um comportamento personalizado. Implemente as interfaces <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> ou <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> diretamente ou use o método <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> para criar um bloco complexo que encapsula o comportamento dos tipos de bloco existentes. Para obter exemplos que mostram como implementar a funcionalidade de bloco de fluxo de dados personalizado, consulte [Passo a passo: criando um tipo de bloco de fluxo de dados personalizado](walkthrough-creating-a-custom-dataflow-block-type.md).

## <a name="related-topics"></a>Tópicos relacionados  
  
|Title|Descrição|  
|-----------|-----------------|  
|[Como: gravar mensagens em um bloco de fluxo de dados e ler mensagens dele](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Demonstra como gravar e ler mensagens de um objeto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>.|  
|[Como: implementar um padrão de fluxo de dados de produtor-consumidor](how-to-implement-a-producer-consumer-dataflow-pattern.md)|Descreve como usar o modelo de fluxo de dados para implementar um padrão de produtor-consumidor, no qual o produtor envia mensagens para um bloco de fluxo de dados e o consumidor lê as mensagens desse bloco.|  
|[Como: executar ações quando um bloco de fluxo de dados recebe dados](how-to-perform-action-when-a-dataflow-block-receives-data.md)|Descreve como fornecer representantes para os tipos de bloco de fluxo de dados de execução, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  
|[Passo a passo: criar um pipeline de fluxo de dados](walkthrough-creating-a-dataflow-pipeline.md)|Descreve como criar um pipeline de fluxo de dados que baixa texto da Web e executa operações nesse texto.|  
|[Como: desvincular blocos de fluxo de dados](how-to-unlink-dataflow-blocks.md)|Demonstra como usar o método <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> para desvincular um bloco de destino de sua origem depois que a origem oferecer uma mensagem para o destino.|  
|[Passo a passo: usar um fluxo de dados em um aplicativo do Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md)|Demonstra como criar uma rede de blocos de fluxo de dados que executam o processamento de imagens em um Aplicativo do Windows Forms.|  
|[Como: cancelar um bloco de fluxo de dados](how-to-cancel-a-dataflow-block.md)|Demonstra como usar cancelamento em um Aplicativo do Windows Forms.|  
|[Como: usar JoinBlock para ler dados de várias fontes](how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Explica como usar a classe <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> para executar uma operação quando os dados estão disponíveis de várias fontes e como usar o modo não greedy para habilitar vários blocos de junção a compartilharem uma fonte de dados com mais eficiência.|  
|[Como: especificar o grau de paralelismo em um bloco de fluxo de dados](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Descreve como definir a propriedade <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> para habilitar um bloco de fluxo de execução a processar mais de uma mensagem por vez.|  
|[Como: especificar um agendador de tarefas em um bloco de fluxo de dados](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Demonstra como associar um agendador de tarefas específico quando você usa o fluxo de dados em seu aplicativo.|  
|[Passo a passo: usando BatchBlock e BatchedJoinBlock para melhorar a eficiência](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Descreve como usar a classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> para aumentar a eficiência das operações de inserção de banco de dados e como usar a classe <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> para capturar os resultados e também quaisquer exceções que ocorram enquanto o programa lê de um banco de dados.|  
|[Passo a passo: criando um tipo de bloco de fluxo de dados personalizado](walkthrough-creating-a-custom-dataflow-block-type.md)|Demonstra duas maneiras de criar um tipo de bloco de fluxo de dados que implementa o comportamento personalizado.|  
|[Biblioteca de tarefas paralelas (TPL)](task-parallel-library-tpl.md)|Apresenta a TPL, uma biblioteca que simplifica a programação paralela e simultânea em aplicativos .NET Framework.|
